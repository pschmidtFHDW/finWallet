{"ast":null,"code":"import { from, Observable, EMPTY } from 'rxjs';\nimport { tap } from 'rxjs/operators';\n/**\n * Lazy loads Firebase Performance monitoring and returns the instance as\n * an observable\n * @param app\n * @returns Observable<FirebasePerformance>\n */\n\nvar getPerformance$ = function (app) {\n  return from(import('firebase/performance').then(function (module) {\n    return module.getPerformance(app);\n  }));\n};\n/**\n * Creates an observable that begins a trace with a given id. The trace is ended\n * when the observable unsubscribes. The measurement is also logged as a performance\n * entry.\n * @param traceId\n * @returns Observable<void>\n */\n\n\nvar trace$ = function (traceId) {\n  if (typeof window !== 'undefined' && window.performance) {\n    var entries = window.performance.getEntriesByName(traceId, 'measure') || [];\n    var startMarkName_1 = \"_\" + traceId + \"Start[\" + entries.length + \"]\";\n    var endMarkName_1 = \"_\" + traceId + \"End[\" + entries.length + \"]\";\n    return new Observable(function (emitter) {\n      window.performance.mark(startMarkName_1);\n      emitter.next();\n      return {\n        unsubscribe: function () {\n          window.performance.mark(endMarkName_1);\n          window.performance.measure(traceId, startMarkName_1, endMarkName_1);\n        }\n      };\n    });\n  } else {\n    return EMPTY;\n  }\n};\n/**\n * Creates a function that creates an observable that begins a trace with a given id. The trace is ended\n * when the observable unsubscribes. The measurement is also logged as a performance\n * entry.\n * @param name\n * @returns (source$: Observable<T>) => Observable<T>\n */\n\n\nvar trace = function (name) {\n  return function (source$) {\n    return new Observable(function (subscriber) {\n      var traceSubscription = trace$(name).subscribe();\n      return source$.pipe(tap(function () {\n        return traceSubscription.unsubscribe();\n      }, function () {}, function () {\n        return traceSubscription.unsubscribe();\n      })).subscribe(subscriber);\n    });\n  };\n};\n/**\n * Creates a function that creates an observable that begins a trace with a given name. The trace runs until\n * a condition resolves to true and then the observable unsubscribes and ends the trace.\n * @param name\n * @param test\n * @param options\n * @returns (source$: Observable<T>) => Observable<T>\n */\n\n\nvar traceUntil = function (name, test, options) {\n  return function (source$) {\n    return new Observable(function (subscriber) {\n      var traceSubscription = trace$(name).subscribe();\n      return source$.pipe(tap(function (a) {\n        return test(a) && traceSubscription.unsubscribe();\n      }, function () {}, function () {\n        return options && options.orComplete && traceSubscription.unsubscribe();\n      })).subscribe(subscriber);\n    });\n  };\n};\n/**\n * Creates a function that creates an observable that begins a trace with a given name. The trace runs while\n * a condition resolves to true. Once the condition fails the observable unsubscribes\n * and ends the trace.\n * @param name\n * @param test\n * @param options\n * @returns (source$: Observable<T>) => Observable<T>\n */\n\n\nvar traceWhile = function (name, test, options) {\n  return function (source$) {\n    return new Observable(function (subscriber) {\n      var traceSubscription;\n      return source$.pipe(tap(function (a) {\n        if (test(a)) {\n          traceSubscription = traceSubscription || trace$(name).subscribe();\n        } else {\n          if (traceSubscription) {\n            traceSubscription.unsubscribe();\n          }\n\n          traceSubscription = undefined;\n        }\n      }, function () {}, function () {\n        return options && options.orComplete && traceSubscription && traceSubscription.unsubscribe();\n      })).subscribe(subscriber);\n    });\n  };\n};\n/**\n * Creates a function that creates an observable that begins a trace with a given name. The trace runs until the\n * observable fully completes.\n * @param name\n * @returns (source$: Observable<T>) => Observable<T>\n */\n\n\nvar traceUntilComplete = function (name) {\n  return function (source$) {\n    return new Observable(function (subscriber) {\n      var traceSubscription = trace$(name).subscribe();\n      return source$.pipe(tap(function () {}, function () {}, function () {\n        return traceSubscription.unsubscribe();\n      })).subscribe(subscriber);\n    });\n  };\n};\n/**\n * Creates a function that creates an observable that begins a trace with a given name.\n * The trace runs until the first value emits from the provided observable.\n * @param name\n * @returns (source$: Observable<T>) => Observable<T>\n */\n\n\nvar traceUntilFirst = function (name) {\n  return function (source$) {\n    return new Observable(function (subscriber) {\n      var traceSubscription = trace$(name).subscribe();\n      return source$.pipe(tap(function () {\n        return traceSubscription.unsubscribe();\n      }, function () {}, function () {})).subscribe(subscriber);\n    });\n  };\n};\n\nexport { getPerformance$, trace, traceUntil, traceUntilComplete, traceUntilFirst, traceWhile }; //# sourceMappingURL=index.esm.js.map","map":null,"metadata":{},"sourceType":"module"}